<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°çŒ´çš®çš®éŸ³é¢‘æ ¼å¼è½¬æ¢å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .drop-zone {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            background: #f8f9ff;
        }
        
        .drop-zone:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }
        
        .drop-zone.dragover {
            border-color: #764ba2;
            background: #e8ebff;
            transform: scale(1.02);
        }
        
        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .drop-zone-text {
            color: #667eea;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .drop-zone-hint {
            color: #999;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .supported-formats {
            display: inline-block;
            margin-top: 8px;
            padding: 8px 15px;
            background: #e8f4f8;
            border-radius: 8px;
            font-size: 12px;
            color: #555;
        }
        
        .action-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #5a6268;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .file-list {
            margin-top: 30px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .file-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-name {
            flex: 1;
            color: #333;
            font-size: 14px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 10px;
        }
        
        .file-status {
            font-size: 12px;
            padding: 5px 10px;
            border-radius: 5px;
            white-space: nowrap;
        }
        
        .status-processing {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-success {
            background: #d4edda;
            color: #155724;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .download-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
            transition: background 0.3s;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
        }
        
        .download-btn:hover {
            background: #764ba2;
        }
        
        .specs {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 13px;
            color: #555;
        }
        
        .specs-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        
        .progress-info {
            text-align: center;
            margin-top: 15px;
            color: #667eea;
            font-weight: bold;
        }
        
        input[type="file"] {
            display: none;
        }

        .file-list::-webkit-scrollbar {
            width: 8px;
        }

        .file-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .file-list::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        .file-list::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }

        .format-badge {
            display: inline-block;
            padding: 2px 6px;
            margin: 2px;
            background: #667eea;
            color: white;
            border-radius: 4px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸµ å°çŒ´çš®çš®éŸ³é¢‘æ ¼å¼è½¬æ¢å™¨</h1>
        <p class="subtitle">å°çŒ´çš®çš®ç‚¹è¯»ç¬”å…¼å®¹wavæ ¼å¼</p>
        
        <div class="drop-zone" id="dropZone">
            <div class="drop-zone-icon">ğŸ“</div>
            <div class="drop-zone-text">æ‹–æ‹½éŸ³é¢‘æ–‡ä»¶åˆ°è¿™é‡Œ</div>
            <div class="drop-zone-hint">
                æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ï¼ˆæ”¯æŒå¤šé€‰ï¼‰
                <div class="supported-formats">
                    <span class="format-badge">MP3</span>
                    <span class="format-badge">WAV</span>
                    <span class="format-badge">OGG</span>
                    <span class="format-badge">M4A</span>
                    <span class="format-badge">AAC</span>
                    <span class="format-badge">FLAC</span>
                    <span class="format-badge">WEBM</span>
                </div>
            </div>
        </div>
        
        <input type="file" id="fileInput" accept="audio/*,.mp3,.wav,.ogg,.m4a,.aac,.flac,.webm,.opus,.wma" multiple>
        
        <div class="action-buttons">
            <button class="btn btn-primary" id="downloadAllBtn" disabled>
                ğŸ“¦ æ‰“åŒ…ä¸‹è½½å…¨éƒ¨ (0)
            </button>
            <button class="btn btn-secondary" id="clearBtn" disabled>
                ğŸ—‘ï¸ æ¸…ç©ºåˆ—è¡¨
            </button>
        </div>
        
        <div class="progress-info" id="progressInfo"></div>
        
        <div class="file-list" id="fileList"></div>
        
        <div class="specs">
            <div class="specs-title">ğŸ“‹ è½¬æ¢è§„æ ¼ï¼š</div>
            â€¢ å•å£°é“ (Mono)<br>
            â€¢ é‡‡æ ·ç‡: 16000 Hz<br>
            â€¢ ç¼–ç : PCM 16-bit<br>
            <br>
            <div class="specs-title">ğŸ¯ æ”¯æŒæ ¼å¼ï¼š</div>
            â€¢ <strong>å¸¸ç”¨æ ¼å¼ï¼š</strong>MP3, WAV, OGG, M4A, AAC<br>
            â€¢ <strong>é«˜å“è´¨ï¼š</strong>FLAC (æ— æŸ)<br>
            â€¢ <strong>ç½‘ç»œæ ¼å¼ï¼š</strong>WebM, Opus<br>
            â€¢ <strong>å…¶ä»–ï¼š</strong>WMA ç­‰ï¼ˆå–å†³äºæµè§ˆå™¨æ”¯æŒï¼‰
        </div>
    </div>

    <!-- å¼•å…¥ JSZip åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const clearBtn = document.getElementById('clearBtn');
        const progressInfo = document.getElementById('progressInfo');

        let convertedFiles = []; // å­˜å‚¨è½¬æ¢åçš„æ–‡ä»¶
        let totalFiles = 0;
        let completedFiles = 0;

        // æ”¯æŒçš„éŸ³é¢‘æ ¼å¼ï¼ˆWeb Audio API å¯ä»¥è§£ç çš„æ ¼å¼ï¼‰
        const SUPPORTED_FORMATS = {
            // MIME types
            'audio/mpeg': true,        // MP3
            'audio/mp3': true,         // MP3
            'audio/wav': true,         // WAV
            'audio/wave': true,        // WAV
            'audio/x-wav': true,       // WAV
            'audio/ogg': true,         // OGG
            'audio/webm': true,        // WebM
            'audio/flac': true,        // FLAC
            'audio/x-flac': true,      // FLAC
            'audio/mp4': true,         // M4A
            'audio/m4a': true,         // M4A
            'audio/x-m4a': true,       // M4A
            'audio/aac': true,         // AAC
            'audio/aacp': true,        // AAC
            'audio/opus': true,        // Opus
            'audio/x-ms-wma': true,    // WMA
            
            // æ–‡ä»¶æ‰©å±•å
            '.mp3': true,
            '.wav': true,
            '.ogg': true,
            '.oga': true,
            '.webm': true,
            '.flac': true,
            '.m4a': true,
            '.aac': true,
            '.opus': true,
            '.wma': true
        };

        // ç‚¹å‡»ä¸Šä¼ 
        dropZone.addEventListener('click', () => fileInput.click());

        // æ‹–æ‹½äº‹ä»¶
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        // æ‰“åŒ…ä¸‹è½½å…¨éƒ¨
        downloadAllBtn.addEventListener('click', async () => {
            if (convertedFiles.length === 0) return;

            downloadAllBtn.disabled = true;
            downloadAllBtn.textContent = 'ğŸ“¦ æ‰“åŒ…ä¸­...';

            try {
                const zip = new JSZip();
                const folder = zip.folder('wav_fixed');

                // æ·»åŠ æ‰€æœ‰æ–‡ä»¶åˆ° ZIP
                for (const file of convertedFiles) {
                    folder.file(file.name, file.blob);
                }

                // ç”Ÿæˆ ZIP æ–‡ä»¶
                const zipBlob = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                }, (metadata) => {
                    const percent = metadata.percent.toFixed(0);
                    downloadAllBtn.textContent = `ğŸ“¦ æ‰“åŒ…ä¸­ ${percent}%`;
                });

                // ä¸‹è½½ ZIP æ–‡ä»¶
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'wav_fixed.zip';
                a.click();
                URL.revokeObjectURL(url);

                downloadAllBtn.textContent = `ğŸ“¦ æ‰“åŒ…ä¸‹è½½å…¨éƒ¨ (${convertedFiles.length})`;
            } catch (error) {
                console.error('æ‰“åŒ…å¤±è´¥:', error);
                alert('æ‰“åŒ…å¤±è´¥ï¼Œè¯·é‡è¯•');
                downloadAllBtn.textContent = `ğŸ“¦ æ‰“åŒ…ä¸‹è½½å…¨éƒ¨ (${convertedFiles.length})`;
            } finally {
                downloadAllBtn.disabled = false;
            }
        });

        // æ¸…ç©ºåˆ—è¡¨
        clearBtn.addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ–‡ä»¶å—ï¼Ÿ')) {
                fileList.innerHTML = '';
                convertedFiles = [];
                totalFiles = 0;
                completedFiles = 0;
                updateButtons();
                updateProgress();
            }
        });

        function isAudioFile(file) {
            // æ£€æŸ¥ MIME type
            if (file.type && SUPPORTED_FORMATS[file.type]) {
                return true;
            }
            
            // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
            const ext = '.' + file.name.split('.').pop().toLowerCase();
            if (SUPPORTED_FORMATS[ext]) {
                return true;
            }
            
            // é€šç”¨éŸ³é¢‘ç±»å‹æ£€æŸ¥
            if (file.type && file.type.startsWith('audio/')) {
                return true;
            }
            
            return false;
        }

        function handleFiles(files) {
            const audioFiles = Array.from(files).filter(file => isAudioFile(file));

            if (audioFiles.length === 0) {
                alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶\n\næ”¯æŒæ ¼å¼ï¼šMP3, WAV, OGG, M4A, AAC, FLAC, WebM, Opus ç­‰');
                return;
            }

            const unsupportedCount = files.length - audioFiles.length;
            if (unsupportedCount > 0) {
                console.warn(`è·³è¿‡ ${unsupportedCount} ä¸ªä¸æ”¯æŒçš„æ–‡ä»¶`);
            }

            totalFiles += audioFiles.length;
            updateProgress();

            audioFiles.forEach(file => convertFile(file));
        }

        async function convertFile(file) {
            const fileItem = createFileItem(file.name);
            fileList.appendChild(fileItem);

            try {
                updateStatus(fileItem, 'processing', 'è½¬æ¢ä¸­...');

                // è¯»å–æ–‡ä»¶
                const arrayBuffer = await file.arrayBuffer();
                
                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });
                
                // è§£ç éŸ³é¢‘
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // è½¬æ¢ä¸ºå•å£°é“ 16000Hz PCM
                const wavBlob = audioBufferToWav(audioBuffer);
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const url = URL.createObjectURL(wavBlob);
                
                // è·å–åŸæ–‡ä»¶åï¼ˆå»æ‰æ‰©å±•åï¼‰å¹¶æ·»åŠ  .wav
                const originalName = file.name.substring(0, file.name.lastIndexOf('.')) || file.name;
                const fileName = originalName + '.wav';
                
                // ä¿å­˜åˆ°è½¬æ¢åˆ—è¡¨
                convertedFiles.push({
                    name: fileName,
                    blob: wavBlob,
                    url: url
                });

                completedFiles++;
                updateProgress();
                updateStatus(fileItem, 'success', 'âœ… å®Œæˆ');
                addDownloadButton(fileItem, url, fileName);
                updateButtons();

            } catch (error) {
                console.error('è½¬æ¢å¤±è´¥:', error);
                completedFiles++;
                updateProgress();
                
                // æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                let errorMsg = 'âŒ å¤±è´¥';
                if (error.name === 'EncodingError') {
                    errorMsg = 'âŒ æ ¼å¼ä¸æ”¯æŒ';
                } else if (error.message.includes('decode')) {
                    errorMsg = 'âŒ è§£ç å¤±è´¥';
                }
                
                updateStatus(fileItem, 'error', errorMsg);
            }
        }

        function createFileItem(fileName) {
            const div = document.createElement('div');
            div.className = 'file-item';
            div.innerHTML = `
                <span class="file-name" title="${fileName}">${fileName}</span>
                <span class="file-status"></span>
            `;
            return div;
        }

        function updateStatus(fileItem, type, text) {
            const status = fileItem.querySelector('.file-status');
            status.className = `file-status status-${type}`;
            status.textContent = text;
        }

        function addDownloadButton(fileItem, url, fileName) {
            const btn = document.createElement('button');
            btn.className = 'download-btn';
            btn.textContent = 'ä¸‹è½½';
            btn.onclick = () => {
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.click();
            };
            fileItem.appendChild(btn);
        }

        function updateButtons() {
            const hasFiles = convertedFiles.length > 0;
            downloadAllBtn.disabled = !hasFiles;
            clearBtn.disabled = !hasFiles;
            downloadAllBtn.textContent = `ğŸ“¦ æ‰“åŒ…ä¸‹è½½å…¨éƒ¨ (${convertedFiles.length})`;
        }

        function updateProgress() {
            if (totalFiles === 0) {
                progressInfo.textContent = '';
            } else if (completedFiles < totalFiles) {
                progressInfo.textContent = `â³ è½¬æ¢è¿›åº¦: ${completedFiles}/${totalFiles}`;
            } else {
                progressInfo.textContent = `âœ… å…¨éƒ¨å®Œæˆï¼å…± ${totalFiles} ä¸ªæ–‡ä»¶`;
            }
        }

        function audioBufferToWav(audioBuffer) {
            // è½¬æ¢ä¸ºå•å£°é“
            const channelData = audioBuffer.numberOfChannels > 1 
                ? mergeChannels(audioBuffer)
                : audioBuffer.getChannelData(0);

            const samples = new Int16Array(channelData.length);
            
            // è½¬æ¢ä¸º 16-bit PCM
            for (let i = 0; i < channelData.length; i++) {
                const s = Math.max(-1, Math.min(1, channelData[i]));
                samples[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }

            // åˆ›å»º WAV æ–‡ä»¶
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);

            // WAV æ–‡ä»¶å¤´
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, 16000, true);
            view.setUint32(28, 16000 * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, samples.length * 2, true);

            const offset = 44;
            for (let i = 0; i < samples.length; i++) {
                view.setInt16(offset + i * 2, samples[i], true);
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        function mergeChannels(audioBuffer) {
            const channels = [];
            for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                channels.push(audioBuffer.getChannelData(i));
            }
            
            const merged = new Float32Array(channels[0].length);
            for (let i = 0; i < merged.length; i++) {
                let sum = 0;
                for (let j = 0; j < channels.length; j++) {
                    sum += channels[j][i];
                }
                merged[i] = sum / channels.length;
            }
            return merged;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>
